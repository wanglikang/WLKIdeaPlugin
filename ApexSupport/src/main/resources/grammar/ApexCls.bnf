// Copyright 2000-2022 JetBrains s.r.o. and other contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
{
  classHeader="//自动生成的语法分析器"
  parserClass="com.wlk.ideaplugin.apexsupport.language.parser.ApexParser"
  parserUtilClass="com.wlk.ideaplugin.apexsupport.language.parser.ApexParserUtil"
  // 在此文件中，运行 【Generate Parse Util】 后，会自动生成一个ApexParserUtil  放到和 parserClass 同一个文件夹下，
  // 并自动生成此配置，然后，此文件的右键选项中，就没有【Generate Parse Util】 的选项了
//  parserUtilClass="com.wlk.ideaplugin.apexsupport.language.parser.ApexParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiImplPackage="com.wlk.ideaplugin.apexsupport.language.gen.psi.impl"
  psiClassPrefix="Apex"
  psiImplClassSuffix="Impl"
  psiPackage="com.wlk.ideaplugin.apexsupport.language.gen.psi"

// 这个 type ，应该是会自动生成的,,生成后，可以被.flex文件所用的
  elementTypeHolderClass="com.wlk.ideaplugin.apexsupport.language.gen.psi.ApexTypes"

  // 应该是根据name，自动生成token的工厂类,应该还用不到
//  tokenTypeFactory="com.wlk.ideaplugin.apexsupport.language.psi.ApexTokenType.createTokenType"


  elementTypeClass="com.wlk.ideaplugin.apexsupport.language.psi.ApexElementType"
  tokenTypeClass="com.wlk.ideaplugin.apexsupport.language.psi.ApexTokenType"

// psiImplUtilClass 暂不知道是干什么的
  psiImplUtilClass="com.wlk.ideaplugin.apexsupport.language.psi.impl.ApexPsiImplUtil"

  tokens=[
    // 有几个内置的flex 变量可以用，参考：org.intellij.grammar.actions.BnfGenerateLexerAction#text2JFlex
    // [:letter:]、[:digit:]、[:lowercase:]、[:uppercase:]、([:letter:]|[:digit:])、[\x00-\x7F]

    Identifier="regexp:[a-zA-Z]+[a-zA-Z0-9]*"
    space = "regexp:\s+"
    string = "regexp:\"[^\"]*\"|'[^']*'"
    number = "regexp:(\\+|\\-)?\d*"
    id = "regexp:\p{Alpha}\w*"


    //整数 字面量
    DecIntegerLiteral = "regexp:0|[1-9][0-9]*"
    DecLongLiteral    = "regexp:0|[1-9][0-9]*[lL]"

    // 十六进制 字面量
//    HexDigit          = "regexp:[0-9a-fA-F]"
    HexIntegerLiteral = "regexp:0[xX]0*[0-9a-fA-F]{1,8}"
    HexLongLiteral    = "regexp:0[xX]0*[0-9a-fA-F]{1,16}[lL]"

    // 八进制 字面量
//    OctDigit          = "regexp:[0-7]"
    OctIntegerLiteral = "regexp:0+[1-3]?[0-7]{1,15}"
    OctLongLiteral    = "regexp:0+1?[0-7]{1,21}[lL]"

    // 浮点数 字面量
    /* floating point literals */
//    FLit1    = "regexp:[0-9]+\.[0-9]*"
//    FLit2    = "regexp:\.[0-9]+"
//    FLit3    = "regexp:[0-9]+"
//    Exponent = "regexp:[eE][+-]? [0-9]+"
    FloatLiteral  = "regexp:([0-9]+\.[0-9]*|\.[0-9]+|[0-9]+)[eE][+-]?[0-9]+?[fF]"
    DoubleLiteral = "regexp:([0-9]+\.[0-9]*|\.[0-9]+|[0-9]+)[eE][+-]?[0-9]+?"

    //字符串字面量(单引号包裹的）

    SingleQuoteStringLiteral = "regexp:'[a-z]+'"

    // 分隔符
    LPAREN = "("
    RPAREN = ")"
    comma = ","
    colon = ":"
    SEMI = ";"
    DOT = "."
    LBRACE = "{"
    RBRACE = "}"
    LBRACK = "["
    RBRACK = "]"

    // 操作符
    ASSIGN = "="
    GT = ">"
    LT = "<"
    BANG = "!"
    TILDE = "~"
    QUESTION = "?"
    COLON = ":"
    EQUAL = "=="
    LE = "<="
    GE = ">="
    NOTEQUAL = "!="
    AND = "&&"
    OR = "||"
    INC = "++"
    DEC = "--"
    ADD = "+"
    SUB = "-"
    MUL = "*"
    DIV = "/"
    BITAND = "&"
    BITOR = "|"
    CARET = "^"
    MOD = "%"
    ADD_ASSIGN = "+="
    SUB_ASSIGN = "-="
    MUL_ASSIGN = "*="
    DIV_ASSIGN = "/="
    AND_ASSIGN = "&="
    OR_ASSIGN = "|="
    XOR_ASSIGN = "^="
    MOD_ASSIGN = "%="
    LSHIFT_ASSIGN = "<<="
    RSHIFT_ASSIGN = ">>="
    URSHIFT_ASSIGN = ">>>="
    LAMBDA_LIKE = "=>"

    DB_INSERT = "insert"
    DB_UPSERT = "upsert"
    DB_UPDATE = "update"
    DB_DELETE = "delete"
    DB_UNDELETE = "undelete"
    NEW = "new"
    THIS = "this"
    CLASS = "class"
    SUPER = "super"
    PUBLIC="public"
    PROTECTED = "protected"
    PRIVATE = "private"
    STATIC = "static"
    ABSTRACT = "abstract"
    FINAL = "final"
    GLOBAL = "global"
    WEBSERVICE = "webservice"
    OVERRIDE = "override"
    VIRTUAL = "virtual"
    TESTMETHOD = "testmethod"
    APEX_WITH_SHARING = "with sharing"
    APEX_WITHOUT_SHARING = "without sharing"
    IF = "if"
    ELSE = "else"
    FOR = "for"
    WHILE = "while"
    DO = "do"
    RUNAS = "runas"
    TRY = "try"
    RETURN = "return"
    THROW = "throw"
    BREAK = "break"
    CONTINUE = "continue"


    WS =  "regexp:[\t\r\n\u000C]+ "
    APEXDOC_COMMENT = "regexp:/\*\*[\r\n].*?\*/"
    APEXDOC_COMMENT_START = "^/**"
    COMMENT = "regexp:/\*.*?\*/"
    LINE_COMMENT = "regexp://[^\r\n]*[\r|\n]?"
  ]
}

compilationUnit ::= packageDeclaration? importDeclaration* typeDeclaration*

packageDeclaration::=  annotation* "PACKAGE" qualifiedName ';'
    ;

importDeclaration::= "IMPORT" "STATIC"? qualifiedName ('.' '*')? ';'
    ;
typeDeclaration ::= classOrInterfaceModifier* classDeclaration
    | ';'
    ;

classOrInterfaceModifier::= annotation           // class or interface
    | "PUBLIC"               // class or interface
    | "PROTECTED"            // class or interface
    | "PRIVATE"              // class or interface
    | "STATIC"               // class or interface
    | "ABSTRACT"             // class or interface
    | "FINAL"                // class only -- does not apply to interfaces
    | "GLOBAL"               // class or interface
    | "WEBSERVICE"           // class only -- does not apply to interfaces
    | "OVERRIDE"             // method only
    | "VIRTUAL"              // method only
    | "TESTMETHOD"           // method only
    | "APEX_WITH_SHARING"    // class only
    | "APEX_WITHOUT_SHARING" //class only
    ;
classDeclaration::= "CLASS" Identifier typeParameters? ("EXTENDS" type_)? ("IMPLEMENTS" typeList)? classBody
    ;

typeParameters::= '<' typeParameter (',' typeParameter)* '>'
    ;

typeParameter::= Identifier ("EXTENDS" typeBound)?
    ;

typeBound::= type_ ('&' type_)*
    ;
classBody ::= '{' classBodyDeclaration* '}'
    ;
classBodyDeclaration ::= ';'
    | "STATIC"? block
    | modifier* memberDeclaration
    ;
memberDeclaration::= methodDeclaration
//    | genericMethodDeclaration
    | fieldDeclaration
//    | constructorDeclaration
//    | genericConstructorDeclaration
//    | interfaceDeclaration
//    | annotationTypeDeclaration
    | classDeclaration
//    | enumDeclaration
//    | propertyDeclaration
    ;
methodDeclaration::= "OVERRIDE"? (type_ | "VOID") Identifier formalParameters ('[' ']')* ("THROWS" qualifiedNameList)? (
        methodBody
        | ';'
    )
    ;
methodBody::= block
    ;
formalParameters::= '(' formalParameterList? ')'
    ;

formalParameterList::= formalParameter (',' formalParameter)* (',' lastFormalParameter)?
    | lastFormalParameter
    ;

formalParameter::= variableModifier* type_ variableDeclaratorId
    ;
lastFormalParameter::= variableModifier* type_ '...' variableDeclaratorId
    ;
fieldDeclaration::= type_ variableDeclarators ';'
    ;
modifier::= classOrInterfaceModifier
    | "NATIVE"
    | "SYNCHRONIZED"
    | "TRANSIENT"
    ;
block ::= '{' blockStatement* '}'
    ;
blockStatement ::= localVariableDeclarationStatement
    | statement
    | typeDeclaration
    ;
localVariableDeclarationStatement ::= localVariableDeclaration ';'
    ;
localVariableDeclaration ::= variableModifier* type_ variableDeclarators
    ;
variableDeclarators::= variableDeclarator (',' variableDeclarator)*
    ;
variableDeclarator::= variableDeclaratorId ('=' variableInitializer)?
    ;

variableInitializer::= arrayInitializer
    | expression
    ;
arrayInitializer::= '{' (variableInitializer (',' variableInitializer)* ','?)? '}'
    ;


variableDeclaratorId::= Identifier ('[' ']')*
    ;



variableModifier::= "FINAL"
    | annotation
    ;

annotation::= '@' annotationName ('(' ( elementValuePairs | elementValue)? ')')?
    ;
annotationName::= qualifiedName
    ;
qualifiedName::= Identifier ('.' Identifier)*
    ;
elementValuePairs ::= elementValuePair (','? elementValuePair)*
    ;

elementValuePair ::= Identifier '=' elementValue
    ;
elementValue ::= expression
    | annotation
    | elementValueArrayInitializer
    ;
elementValueArrayInitializer::= '{' (elementValue (',' elementValue)*)? ','? '}'
    ;

expression::= primary
//    | expression '.' "GET" '(' expressionList? ')'
//    | expression '.' "SET" '(' expressionList? ')'
//    | expression '?'? '.' Identifier
//    | expression '.' "THIS"
//    | expression '.' "NEW"
//    | expression '.' ("DB_INSERT" | "DB_UPSERT" | "DB_UPDATE" | "DB_DELETE" | "DB_UNDELETE")
//    | expression '.' "SUPER" superSuffix
//    | expression '.' explicitGenericInvocation
//    | expression '[' expression ']'
//    | expression '(' expressionList? ')'
////    | "NEW" creator
    | '(' type_ ')' expression
//    | expression ('++' | '--')
    | ('+' | '-' | '++' | '--') expression
    | ('~' | '!') expression
//    | expression ('*' | '/' | '%') expression
//    | expression ('+' | '-') expression
//    | expression ('<' '<' | '>' '>' '>' | '>' '>') expression
//    | expression ('<=' | '>=' | '>' | '<') expression
//    | expression "INSTANCEOF" type_
//    | expression ('==' | '!=' | '<>') expression
//    | expression '&' expression
//    | expression '^' expression
//    | expression '|' expression
//    | expression '&&' expression
//    | expression '||' expression
//    | expression '?' expression ':' expression
//    | <assoc = right> expression (
//        '='
//        | '+='
//        | '-='
//        | '*='
//        | '/='
//        | '&='
//        | '|='
//        | '^='
//        | '>>='
//        | '>>>='
//        | '<<='
//        | '%='
//    ) expression
    ;

primary ::= '(' expression ')'
    | "THIS"
    | "SUPER"
    | literal
    | Identifier
    | type_ '.' "CLASS"
    | "VOID" '.' "CLASS"
    | nonWildcardTypeArguments (explicitGenericInvocationSuffix | "THIS" arguments)
//    | SoqlLiteral
    ;
literal::= IntegerLiteral
    | FloatingPointLiteral
//    | CharacterLiteral
    | StringLiteral
//    | BooleanLiteral
    | "NULL"
    ;
IntegerLiteral::= DecIntegerLiteral
    |   DecLongLiteral
    |   HexIntegerLiteral
    |   HexLongLiteral
    |   OctIntegerLiteral
    |   OctLongLiteral
    ;
FloatingPointLiteral::= FloatLiteral
    |   DoubleLiteral
    ;
StringLiteral::= SingleQuoteStringLiteral

nonWildcardTypeArguments::= '<' typeList '>'
    ;
typeList::= type_ (',' type_)*
    ;
type_::= classOrInterfaceType ('[' ']')*
    | primitiveType ('[' ']')*
    ;
classOrInterfaceType ::= Identifier typeArguments? ('.' Identifier typeArguments?)*
    | "SET" typeArguments // 'set <' has to be defined explisitly, otherwise it clashes with SET of property setter
    ;

typeArguments
    ::= '<' typeArgument (',' typeArgument)* '>'
    ;
typeArgument::= type_
    | '?' (("EXTENDS" | "SUPER") type_)?
    ;
primitiveType::= "CHAR"
    | "BYTE"
    | "SHORT"
    | "INT"
    | "FLOAT"
    ;

explicitGenericInvocationSuffix::= "SUPER" superSuffix
    | Identifier arguments
    ;
superSuffix::= arguments
    | '.' Identifier arguments?
    ;
arguments::= '(' expressionList? ')'
    ;
expressionList::= expression (',' expression)*
    ;
explicitGenericInvocation::= nonWildcardTypeArguments explicitGenericInvocationSuffix
    ;

statement::= block
//    | IF parExpression statement (ELSE statement)?
//    | FOR '(' forControl ')' statement
//    | WHILE parExpression statement
//    | DO statement WHILE parExpression ';'
//    | RUNAS '(' expression ')' statement
//    | TRY block (catchClause+ finallyBlock? | finallyBlock)
//    | TRY resourceSpecification block catchClause* finallyBlock?
//    | RETURN expression? ';'
//    | THROW expression ';'
//    | BREAK Identifier? ';'
//    | CONTINUE Identifier? ';'
    | ';'
    | statementExpression ';'
    | Identifier ':' statement
    | apexDbExpression ';'
    ;

statementExpression::= expression
    ;
apexDbExpression::= ("DB_INSERT" | "DB_UPDATE" | "DB_DELETE" | "DB_UNDELETE") expression
    | apexDbUpsertExpression
    ;

apexDbUpsertExpression::= "DB_UPSERT" expression expression*
    ;